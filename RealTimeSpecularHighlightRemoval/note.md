# Real-Time High-Quality Specular Highlight Removal using Efficient Pixel Clustering

## Abstract

最近的镜面高光去除技术通常估计并聚类照明色度值，以从单个图像中分离漫反射和镜面反射分量。虽然这些技术能够获得视觉上令人满意的结果，但它们的**聚类算法初始化不好**，或者**成本太高**，无法**实时计算**。

在本文中，我们提出了一种高质量的像素聚类方法，该方法可以**实时**从单个图像中去除镜面高光。我们遵循之前的工作，**估计每个像素的最小和最大色度值**。然后，我们分析了这些值在最小-最大色度空间中的分布模式，以提出一种有效的像素聚类方法。然后，我们估计每个簇的**强度比**，以便分离漫反射和镜面反射分量。最后，我们提出了优化策略，以有效地针对CPU和GPU架构实现我们的方法。

在可用数据集中评估的实验结果表明，当仅在CPU上运行时，所提出的方法不仅更准确，而且比现有技术快两倍。在GPU上运行，我们发现我们的方法需要≈24毫秒才能去除3840×2160（4k）分辨率图像中的镜面高光。这使得我们的GPU实现比最先进的4k分辨率图像快一个数量级（20倍）以上，同时准确地提供了所需的效果。

## Introduction

计算机视觉应用，如内在图像分解[1]，通常假设场景中存在的材料是纯朗伯的（即没有镜面反射），并将具有镜面反射的区域视为噪声或异常值。在这种情况下，如果图像中存在大的镜面高光区域，则应用程序的精度可能会严重降低

为了简化镜面高光去除的任务，二色反射模型是最常见的假设，用于引导从单个图像中分离漫反射和镜面反射分量。在这样的模型中，在像素处观察到的颜色可以通**过漫反射和镜面反射分量的总和**或者通过**漫色度和镜面色度的线性组合**来描述。通常，大多数现有的精确技术将输入像素的颜色转换为基于色度的空间，该空间允许通过像素聚类来分离漫射和镜面分量。虽然这些技术能够最大限度地减少图像中镜面高光的存在，但它们中的大多数都使用了**聚类**策略，这些策略容易导致聚类种子的初始化不好，或者在处理时间方面过于昂贵。

在这项工作中，我们的主要贡献有三方面：

1）一种高效的像素聚类算法，它提供了改进的聚类种子初始化，并实现了比相关工作更准确的结果；

2） 一种优化策略，使所提出的解决方案的CPU实现速度比相关工作快两倍；

3） 在GPU上实现所提出的解决方案，比高分辨率图像的相关工作快一个数量级以上的结果，同时仍然获得高准确率；

## Related Work

所提出的实时镜面高光去除算法的概述。

给定具有镜面高光（a）的输入图像，我们计算每个像素的最小值（b）、最大值（c）和范围值（d）。然后，我们从最小图像中减去输入图像，以估计伪镜面自由图像（e）。然后，我们估计伪镜面自由图像的每个像素的色度值，并将相关像素的最小（f）和最大（g）色度通道存储到单独的图像中。建立最小-最大色度空间，并且仅在三个聚类（h）中有效地聚类。接下来，对于每个聚类，我们使用最大值和范围值来估计单个强度比。最后，通过镜面高光（j）的分离，使用先前估计的三个强度比来计算真实的无镜面图像（i）。

##  REAL-TIME SPECULAR HIGHLIGHT REMOVAL

设 `I` 为图像，其中 $I(x) = [I_r(x),\ I_g(x),\ I_b(x)]^T$ 中的每个像素 `x` 分别存储红、绿和蓝通道的像素值。根据二色反射模型，像素 $I(x)$ 可以用其漫反射 $D(x)$ 和镜面反射 $S(x)$ 分量的总和来表示
$$
I(x) = D(x) + S(x)
$$
或者，通过漫射 $\Lambda$ 和镜面 $\Gamma$ 色度值的线性组合
$$
I(x) = w_d(x)\Lambda(x) + w_s(x)\Gamma
$$
其中 $w_d$ 和 $w_s$ 是几何表面上漫反射和镜面反射的权重，$\Lambda(x) = [\Lambda_r(x),\ \Lambda_g(x),\ \Lambda_b(x)]^T$，$\Gamma = [\frac{1}{3},\ \frac{1}{3},\ \frac{1}{3}]$ 通常，假设输入图像是均匀和归一化的。

对于相同颜色的曲面，具有镜面高光的图像通常包含仅具有漫反射组件的像素，以及同时具有漫反射和镜面反射组件的图像。因此，为了去除图像的镜面高光，我们需要定义一个颜色空间，在这个颜色空间中，我们能够聚集并进一步**将纯漫反射与镜面像素分离**。我们使用强度比的概念来分离漫反射和镜面反射分量。

设 $I^{min}$ 和 $I^{max}$ 是存储最小值和最大值的**单通道图像**：
$$
I^{\min}(x) = \min(I_r(x),\ I_g(x),\ I_b(x)) = w_d(x)\Lambda^{\min}(x) + w_s(x)\Gamma \\
I^{\max}(x) = \max(I_r(x),\ I_g(x),\ I_b(x)) = w_d(x)\Lambda^{\max}(x) + w_s(x)\Gamma \\
\Lambda^{\min}(x) = \min(\Lambda_r(x),\ \Lambda_g(x),\ \Lambda_b(x)) \\
\Lambda^{\max}(x) = \max(\Lambda_r(x),\ \Lambda_g(x),\ \Lambda_b(x))
$$
 在此基础上，设 $I^{range}$ 是存储 $I^\max$ 和 $I^\min$ 之间的差值的**单通道图像**
$$
I^{range}(x) = I^{\max}(x) - I^{\min}(x) = w_d(x)\Lambda^{range}(x)
$$
为了避免 $I^{range}$ 变为 $0$，可以为这一项加一个很小的值 $\epsilon\geqslant0$

现在可以很容易看出 $I^{range}$ 是一个无镜面的图像，因为该图像不再包含二色反射模型的镜面项 $w_s(x)\Gamma$。

现在将强度比 $I^{ratio}$ 定义为最大值和范围值的比值：
$$
I^{ratio} = \frac{I^{\max}(x)}{I^{range}(x)}
$$
对于具有**纯漫反射**的像素，强度比由最大漫反射色度和范围漫反射色度之间的比率明确定义
$$
I^{ratio} = \frac{w_d(x)\Lambda^{\max}}{w_d(x)(\Lambda^{\max}-\Lambda^{\min})} = \frac{\Lambda^{\max}}{\Lambda^{\max} - \Lambda^{\min}}
$$
但是，对于具有漫反射和镜面反射的像素，强度比为
$$
I^{ratio} = \frac{w_d(x)\Lambda^{\max} + w_s\Gamma}{w_d(x)(\Lambda^{\max}-\Lambda^{\min})}
$$
可以发现，对于具有相同颜色表面或相同漫射色度的像素，镜面像素的强度比高于纯漫射像素。在这个意义上，强度比可以用作有效地分离漫射像素和镜面像素的度量。

为了使用 $I^{ratio}$ 来分离漫反射像素和镜面反射像素，我们需要首先对具有几乎相同漫反射色度的像素进行聚类。为了估计像素的漫色度，让我们使用伪镜面自由图像 $I^{psf}$，通过从 输入图像 $I$ 中减去$I^{\min}$ 可以很容易地获得
$$
I^{psf}(x) = I(x) - I^{\min}(x) = w_d(x)\Lambda^{psf}(x)
$$
与 $I^{range}$ 类似，$I^{psf}$ 不包含二色反射模型的镜面项。与 $I^{range}$不同，$I^{psf}$ 是一个类似于原始输入图像的**三通道图像**，允许估计红色、绿色和蓝色强度的漫射色度。

为了防止 $I^{psf}$ 比 $I$ 暗，并**提高对图像噪声的鲁棒性**，将 $I^{\min}$ 的平均 $\overline{I^{\min}}$添加到 $I^{psf}$ 的每个像素

有了 $I^{psf}$ 每个像素的漫射色度值 $\Lambda^{psf}(x)$ **估计**为
$$
\Lambda^{psf}(x) = \frac{I^{psf}(x)}{I^{psf}_r(x) + I^{psf}_g(x) + I^{psf}_b(x)}
$$
然后计算最大和最小伪漫射色度值，仅针对**可能位于具有镜面高光的区域中的相关像素**。
$$
\Lambda_{\min}^{psf}(x) = \min(\Lambda_r^{psf}(x),\ \Lambda_g^{psf}(x),\ \Lambda_b^{psf}(x))\\
\Lambda_{\max}^{psf}(x) = \max(\Lambda_r^{psf}(x),\ \Lambda_g^{psf}(x),\ \Lambda_b^{psf}(x))
$$
然后通过如下所示来确定像素是否与镜面高光相关 
$$
I^{psf}(x) = 	
\left\{
\begin{aligned}
&\text{relevant},&\qquad &\text{if}\quad I^{\min}(x) > \overline{I^\min(x)}\\
&\text{non-relevant},&\qquad &\text{otherwise} 
\end{aligned}
\right.
$$
从这个意义上说，背景像素和强度值低于平均最小强度 $\overline{I^\min}$ 的像素在进一步计算中被丢弃，因为它们可能不包含镜面像素

> 图二：针对最小（x轴）-最大（yaxis）色度空间的聚类方法。在我们的算法（a）的第一次迭代中，我们选择位于最高最小值（蓝色圆圈）、最高最大值（绿色圆圈）和最低最小色度值（红色圆圈）的三个聚类种子（箭头指向的大圆圈）。然后，我们运行两次k-means迭代，将每个像素与欧几里得空间中最近的聚类种子相关联，根据其关联像素的质心更新聚类种子的位置，并基于更新的聚类种子来关联每个像素（b）

为了对具有相同漫射色度的像素进行聚类，我们将 $I^{psf}$ 的相关像素投影到最小-最大色度空间中，如图2所示。这个空间中的任何像素都以**三角形**的形式投影（这一说法的证明可以在补充文件的第一节中看到），就像图2中看到的那样。我们不是随机选择初始聚类种子的数量和位置，而是利用最小-最大色度空间的样本所在的三角形形状，提出了一种在该空间中进行像素聚类的有效方法。

在实验上，我们已经看到，不是将空间划分为一个或两个聚类，而是将最小最大色度空间分离为三个聚类，为相关像素的聚类提供了准确的解决方案。为此，我们首先选择在最小最大色度空间中投影存储**最高最小值**、**最高最大值**和**最低色度值**的像素作为簇种子，如图2-（a）中的大圆圈所示。在我们的算法中，这些像素被选为簇种子，因为它们可以很容易地从 $\Lambda^{psf}_\min$ 和 $\Lambda^{psf}_\max$​ 中检测到，而它们的投影是在最小最大色度空间中形成的**三角形的顶点**。然后，我们只运行 `k-means` [18]的两次迭代，以将输入图像的每个相关像素与最小最大色度空间中最近的聚类种子相关联，从而将每个聚类种子的位置更新为其投影的相关像素的质心在最小-最大色度空间中（参见图2-（b）中聚类种子的新位置），并将每个像素与最近的更新聚类种子相关联（图2-（b））。使用该算法，我们**能够去除选择初始聚类种子的随机性**，从而提供了一种改进的初始化方案，该方案对图像的方向不变，可以很容易地从$I^{psf}$ 计算，并且需要两次 k 均值迭代才能收敛到准确的解。

> 图三：给定每个簇（a）的强度比的无序阵列，我们可以对这样的阵列（b）进行**排序**，并选择**中值**（（b）中的蓝色矩形）作为所选的强度比r，因为该值将阵列等分为漫射（绿色矩形）和镜面（红色矩形）强度比（c）。
>
> 另一种方法是从无序阵列中**迭代选择**一个值（（d）中的蓝色矩形），该值可以更好地分离集群中的漫反射和镜面反射强度比（e）。

在对具有几乎相同漫射色度的像素进行聚类后，我们需要为每个聚类选择强度比 $r$，该强度比 $r$ 基于 $I^{ratio}$ （7）和（8）将漫射像素与镜面像素分离（图3）。计算每个聚类的 $r$ 的一个聪明想法是，按照升序对与同一聚类种子相关的每个像素的强度比进行**排序**（图3-（b）），然后将位于排序阵列中心位置的强度比作为所选值r（图3-中的1.6），因为它将聚类几乎相等地划分为漫射像素和镜面像素（图3-）。

我们知道，根据输入数组的大小，排序步骤在处理时间方面**可能效率太低**，因此我们提出了一种替代方法来估计r，而**不需要对每个聚类进行任何排序**。我们算法的伪代码列在算法1中。在我们的提案中，我们首先计算 $r$ 作为每个聚类的平均强度比（算法1的第6行，图3-（d）），然后，我们确定聚类中强度比低于或高于 $r$ 的像素数量（算法1第7、9和10行）。如果 $r$ 没有将像素数量几乎相等地划分为漫射组和镜面组，或者，换句话说，如果其中一个组包含的像素比该簇中像素总数的 $\beta$ 分数更多（算法1的第11行和第13行），我们将 $r$ 更改为预定义的步长 $\gamma$（算法3的第12行和第14行），并重复该算法，直到达到最大迭代次数 $\alpha$（算法1的第8行）或更新的 $r$ 正确划分漫射和镜面像素（算法3第15行，图3-（e））。最后，我们为与所选强度比为 $r$ 的聚类相关联的每个像素 $x$ 分配 $I^{ratio}(x)=r$（算法3的第18-22行）。

一旦确定了每个聚类的强度比 $r$，我们就可以如下计算真实的镜面图像 $S$（1）（图1（j））。让我们从（1）和（2）中回忆一下，$S(x) = w_s(x)\Gamma$。现在，我们可以从（4）和（6）中看出，对于具有**纯漫反射**的像素，$I^\max(x) = w_d(x) \Lambda^\max(x)$ 以及 $I^\max(x) = I^{ratio}(x)I^{range}(x)$。因此，$w_d(x)\Lambda^\max(x) = I^{ratio}(x)I^{range}(x)$。然后，可以根据最大强度图像（4）计算 $S$：
$$
I^\max(x) = w_d(x)\Lambda^\max(x) + w_s(x)\Gamma \\
w_s(x)\Gamma = I^\max(x) - w_d(x)\Lambda^\max(x) \\
S(x) = I^{\max}(x) - I^{ratio}(x)I^{range}(x)
$$
根据（6），$S(x) $在（12）中将为零，因为 $I^\max(x) = I^{ratio}(x)I^{range}(x)$。然而，如算法1中所列，在计算（6）之后，改变 $I^{ratio}$ 的值，使得每个聚类使用单个强度比率 $r$，使得（6）成为近似方程。

最后，漫反射图像D（图1-（i））可以很容易地通过输入图像和S之间的减法来计算

## GPU-BASED SPECULAR HIGHLIGHT REMOVAL

默认情况下，我们假设内核中的每个线程都基于其在图像中的对应像素来执行计算。此外，我们的GPU算法处理的所有图像都被创建并存储在 **pitched memory** 中，通过**联合内存访问**优化读写操作。

首先，我们在GPU上的单个内核中计算 $I^\min$（图1-（b））、$I^\max$（图1--（c））和 $I^{range}$（图-1-（d））。(每个线程负责并行计算)

接下来，我们估计 $\overline{I^\min}$，即 $I^\min$ 的平均值，以便对相关和非相关像素进行分类（11）。为此，我们在 $I^\min$ 上运行并行前缀和[19]，以便对 $I^\min$ 进行求和，并估计其平均最小强度。

然后，在另一个内核中，我们计算 $I^{psf}$（9）（图1-（e））、$\Lambda^{psf}$（10。并在单独的图像中存储最小$\Lambda^{psf}_\min$（图1-（f））和最大 $\Lambda^{psf}_\max$（图1-（g））伪漫射色度值。对于此任务，每个线程都并行处理其对应的像素。

在最小最大色度空间中执行像素聚类之前，我们在GPU上定位来自 $\Lambda^{psf}_\min$ 和 $\Lambda^{psf}_\max$ 的三个初始聚类种子。我们使用并行前缀和的优化扫描结构[19]来恢复具有最低、最高最小和最高最大伪漫射色度值的像素。如图2-（a）所示，这些是我们聚类算法的初始聚类种子。在将它们上传到恒定设备内存中后，我们将每个相关像素与其最近的簇种子相关联，这是一种**与像素无关**的操作。因此，在单独的内核中，每个线程在最小最大色度空间中投影其对应的像素，测量投影的像素到三个现有聚类种子的距离，并存储离像素最近的聚类种子的标识符。对于三个聚类中的每一个，我们利用扫描结构并行计算与每个聚类相关的像素数量。接下来，我们运行并行前缀求和来求和这些像素的最小和最大漫反射色度值，并更新聚类种子的质心。在将这些新的聚类种子位置复制到 **恒定内存 (constant memory)** 后，我们并行地运行另一个赋值步骤，将每个相关像素与其更新的最近聚类种子相关联（图2-（b））

正如我们在图3中所示，有两种方法可以计算强度比r，将每个簇划分为漫射像素和镜面像素。在这两种方法中，我们首先使用线程并行计算 $I^{ratio}$（6）。接下来，我们运行扫描操作符来并行计算与每个集群相关联的像素数。对于基于排序的方法，我们将与同一聚类种子相关联的像素复制到一个单独的紧凑数组中。然后，我们运行并行**基数排序**[19]对强度比进行排序（图3-（b）），并并行复制 $I^{ratio}(x)$ 的每个像素 `x` 的所选强度比 `r`。

算法1中列出的基于非排序的方法也可以很容易地并行化。对于每个聚类，我们运行**并行前缀和**来估计与同一聚类种子相关联的像素的平均强度比（算法1的第6-7行）。使用扫描算子，我们对强度比低于r的像素进行计数（算法1的第9行）。在CPU上的**单个线程**中，我们控制 $r$ 上的迭代和更新（算法1的第8行、第11-16行）。接下来，并行地，我们为 $I^{ratio}(x)$ 的每个像素 `x` 复制所选择的强度比 $r$（算法1的第18-19行）。

最后，每个 $GPU$ 线程利用每个集群估计的强度比 $r$，根据方程（12）并行计算D（图1-（i））和S（图1-）的每个像素，这是独立于像素的，并且易于并行。